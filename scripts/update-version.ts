#!/usr/bin/env -S deno run --allow-read --allow-write
/**
 * Update Version Script
 *
 * Reads version from root deno.jsonc and generates shared/version.ts
 * This ensures version consistency across the entire codebase.
 *
 * Usage:
 *   deno run --allow-read --allow-write scripts/update-version.ts
 *   deno task update-version
 */

import { parse } from '@std/jsonc';

const DENO_CONFIG_PATH = './deno.jsonc';
const VERSION_FILE_PATH = './shared/version.ts';

interface DenoConfig {
  name?: string;
  version?: string;
  [key: string]: unknown;
}

async function main() {
  try {
    // Read and parse deno.jsonc
    console.log('üìñ Reading version from deno.jsonc...');
    const denoConfigText = await Deno.readTextFile(DENO_CONFIG_PATH);
    const denoConfig = parse(denoConfigText) as DenoConfig;

    if (!denoConfig.version) {
      console.error('‚ùå Error: No version found in deno.jsonc');
      Deno.exit(1);
    }

    const version = denoConfig.version;
    const packageName = denoConfig.name || '@beyondbetter/tools';

    console.log(`‚úÖ Found version: ${version}`);

    // Generate version.ts content
    const versionFileContent = `/**
 * @module
 * Version information for the MCP Client Inspector.
 *
 * This file is auto-generated by scripts/update-version.ts.
 * DO NOT EDIT MANUALLY - Changes will be overwritten
 * 
 * Source: deno.jsonc (root)
 * Last updated: ${new Date().toISOString()}
 */

/**
 * Current version of the MCP Client Inspector package.
 *
 * This version is synchronized with the version in deno.jsonc and follows
 * semantic versioning (semver) conventions.
 */

/**
 * Current package version
 * @constant
 */
export const VERSION = '${version}';

/**
 * Package name
 * @constant
 */
export const PACKAGE_NAME = '${packageName}';

/**
 * Full version string with package name
 * @constant
 */
export const FULL_VERSION = \`\${PACKAGE_NAME}@\${VERSION}\`;

/**
 * Parse version into major, minor, patch components
 * @returns Object with major, minor, and patch version numbers
 */
export function parseVersion(): {
  major: number;
  minor: number;
  patch: number;
  prerelease?: string;
} {
  const match = VERSION.match(/^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(.+))?$/);
  
  if (!match) {
    throw new Error(\`Invalid version format: \${VERSION}\`);
  }

  return {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: parseInt(match[3], 10),
    prerelease: match[4],
  };
}
`;

    // Write version.ts
    console.log(`üìù Writing to ${VERSION_FILE_PATH}...`);
    await Deno.writeTextFile(VERSION_FILE_PATH, versionFileContent);

    console.log('‚úÖ Version file updated successfully!');
    console.log(`   Package: ${packageName}`);
    console.log(`   Version: ${version}`);
    console.log(`   File: ${VERSION_FILE_PATH}`);
  } catch (error) {
    console.error('‚ùå Error updating version:', error);
    Deno.exit(1);
  }
}

if (import.meta.main) {
  main();
}
